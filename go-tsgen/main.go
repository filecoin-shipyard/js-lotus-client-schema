package main

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/alanshaw/go2ts"
	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/go-state-types/abi"
	"github.com/filecoin-project/lotus/api"
	"github.com/filecoin-project/lotus/chain/types"
	"github.com/ipfs/go-cid"
)

func main() {
	var api struct{ api.FullNode }

	t := reflect.TypeOf(api)
	c := go2ts.NewConverter()

	// weird/exceptional types
	c.AddTypes(map[reflect.Type]string{
		reflect.TypeOf(cid.Cid{}):         "Cid",
		reflect.TypeOf([]byte{}):          "string", // base64 encoded
		reflect.TypeOf(abi.Randomness{}):  "string", // base64 encoded
		reflect.TypeOf(types.BigInt{}):    "string",
		reflect.TypeOf(address.Address{}): "string",
		reflect.TypeOf(types.TipSetKey{}): "Cid[]",
		// workaround for recursive Subcalls property on ExecutionTrace
		reflect.TypeOf([]types.ExecutionTrace{}): "ExecutionTrace[]",
	})

	c.AddParamNames(map[reflect.Type]string{
		reflect.TypeOf([]byte{}):       "bytes",
		reflect.TypeOf(types.BigInt{}): "bigInt",
	})

	decls := []string{
		"// Code generated by github.com/filecoin-shipyard/js-lotus-client-schema/go-tsgen. DO NOT EDIT.",
		"declare type Cid = { '/': string }",
	}
	exports := []string{"LotusRPC", "Cid"}

	// for when the exported struct is not the struct used
	exportOverrides := map[reflect.Type]interface{}{
		reflect.TypeOf(types.TipSet{}): types.ExpTipSet{},
	}

	typeNames := map[string]reflect.Type{}
	uniqueTypeName := func(t reflect.Type) (name string) {
		n := 0
		for {
			if n == 0 {
				name = t.Name()
			} else {
				name = fmt.Sprintf("%s%d", t.Name(), n)
			}
			ct, ok := typeNames[name]
			if ok && ct == t {
				break
			} else if !ok {
				typeNames[name] = t
				break
			}
			n++
		}
		return
	}

	c.OnConvert = func(t reflect.Type, ts string) {
		if t.Kind() != reflect.Struct || t.Name() == "" {
			return
		}

		ori, ok := exportOverrides[t]
		if ok {
			ts = c.Convert(reflect.TypeOf(ori))
		}

		name := uniqueTypeName(t)
		decls = append(decls, fmt.Sprintf("declare type %s = %s", name, ts))
		exports = append(exports, name)
		c.AddTypes(map[reflect.Type]string{t: name})
	}

	mdocs := extractMethodDocs()
	methods := []string{"constructor (provider: any, options: { schema: any })"}
	for i := 0; i < t.NumMethod(); i++ {
		m := t.Method(i)
		c.ConfigureFunc = func(t reflect.Type) go2ts.FuncConf {
			fconf := go2ts.FuncConf{IsMethod: true, MethodName: m.Name}
			if t.NumOut() > 0 && t.Out(0).Kind() == reflect.Chan {
				fconf.IsSync = true
			}
			return fconf
		}
		ts := c.Convert(m.Type)

		// deal with the API for subscriptions.
		//
		// go2ts generates a method that returns an AsyncIterable, we need to
		// convert into a method that takes a handler function as the first param
		// and returns a tuple with a cancel function and a ready promise. e.g.
		//
		// clientRetrieveWithEvents (retrievalOrder: RetrievalOrder, fileRef: FileRef): AsyncIterable<RetrievalEvent>
		// is converted to:
		// clientRetrieveWithEvents (handler: (data: RetrievalEvent) => void, retrievalOrder: RetrievalOrder, fileRef: FileRef): [() => void, Promise<void>]
		if isSub(m) {
			parts := strings.Split(ts, "): ")
			dataType := strings.Replace(parts[1][:len(parts[1])-1], "AsyncIterable<", "", 1)
			ts = parts[0] + "): [() => void, Promise<void>]"
			parts = strings.Split(ts, " (")
			if string(parts[1][0]) != ")" {
				ts = fmt.Sprintf("%s (handler: (data: %s) => void, %s", parts[0], dataType, parts[1])
			} else {
				ts = fmt.Sprintf("%s (handler: (data: %s) => void%s", parts[0], dataType, parts[1])
			}
		}

		if strings.HasPrefix(ts, "ID ") {
			ts = strings.Replace(ts, "ID ", "id ", 1)
		} else {
			ts = strings.ToLower(ts[0:1]) + ts[1:]
		}
		if doc, ok := mdocs[m.Name]; ok {
			methods = append(methods, "/**")
			lines := strings.Split(strings.TrimSpace(doc), "\n")
			for i, line := range lines {
				if i == 0 {
					line = strings.ToLower(line[0:1]) + line[1:]
				}
				methods = append(methods, " * "+line)
			}
			methods = append(methods, " */")
		}
		methods = append(methods, ts)
	}

	// custom client methods
	methods = append(methods, "importFile (body: Blob | BufferSource | FormData | URLSearchParams | string | ReadableStream): string")
	methods = append(methods, "destroy (code?: number): void")

	decls = append(decls, fmt.Sprintf("declare class LotusRPC {\n  %s\n}", strings.Join(methods, "\n  ")))
	decls = append(decls, fmt.Sprintf("export { %s }", strings.Join(exports, ", ")))

	fmt.Println(strings.Join(decls, "\n"))
}

func isSub(m reflect.Method) bool {
	return m.Type.NumOut() >= 2 && m.Type.Out(0).Kind() == reflect.Chan
}
