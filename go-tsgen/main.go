package main

import (
	"fmt"
	"reflect"
	"strings"

	"github.com/alanshaw/go2ts"
	"github.com/filecoin-project/go-address"
	"github.com/filecoin-project/go-state-types/abi"
	"github.com/filecoin-project/lotus/api"
	"github.com/filecoin-project/lotus/chain/types"
	"github.com/ipfs/go-cid"
)

func main() {
	var apiCommon struct{ api.Common }
	var apiFullNode struct{ api.FullNode }
	var apiStorageMiner struct{ api.StorageMiner }
	var apiWorkerAPI struct{ api.WorkerAPI }

	apiTypes := []reflect.Type{
		reflect.TypeOf(apiCommon),
		reflect.TypeOf(apiFullNode),
		reflect.TypeOf(apiStorageMiner),
		reflect.TypeOf(apiWorkerAPI),
	}

	// t := reflect.TypeOf(api)
	c := go2ts.NewConverter()

	// weird/exceptional types
	c.AddTypes(map[reflect.Type]string{
		reflect.TypeOf(cid.Cid{}):         "Cid",
		reflect.TypeOf([]byte{}):          "string", // base64 encoded
		reflect.TypeOf(abi.Randomness{}):  "string", // base64 encoded
		reflect.TypeOf(types.BigInt{}):    "string",
		reflect.TypeOf(address.Address{}): "string",
		reflect.TypeOf(types.TipSetKey{}): "Cid[]",
		// workaround for recursive Subcalls property on ExecutionTrace
		reflect.TypeOf([]types.ExecutionTrace{}): "ExecutionTrace[]",
	})

	c.AddParamNames(map[reflect.Type]string{
		reflect.TypeOf([]byte{}):       "bytes",
		reflect.TypeOf(types.BigInt{}): "bigInt",
	})

	decls := []string{
		"// Code generated by github.com/filecoin-shipyard/js-lotus-client-schema/go-tsgen. DO NOT EDIT.",
		"declare type Cid = { '/': string }",
	}
	exports := []string{"LotusRPC", "Cid"}

	// for when the exported struct is not the struct used
	exportOverrides := map[reflect.Type]interface{}{
		reflect.TypeOf(types.TipSet{}): types.ExpTipSet{},
	}

	typeNames := map[string]reflect.Type{}
	uniqueTypeName := func(t reflect.Type) (name string) {
		n := 0
		for {
			if n == 0 {
				name = t.Name()
			} else {
				name = fmt.Sprintf("%s%d", t.Name(), n)
			}
			ct, ok := typeNames[name]
			if ok && ct == t {
				break
			} else if !ok {
				typeNames[name] = t
				break
			}
			n++
		}
		return
	}

	c.OnConvert = func(t reflect.Type, ts string) {
		if t.Kind() != reflect.Struct || t.Name() == "" {
			return
		}

		ori, ok := exportOverrides[t]
		if ok {
			ts = c.Convert(reflect.TypeOf(ori))
		}

		name := uniqueTypeName(t)
		decls = append(decls, fmt.Sprintf("declare type %s = %s", name, ts))
		exports = append(exports, name)
		c.AddTypes(map[reflect.Type]string{t: name})
	}

	mdocs := extractMethodDocs()
	methods := []string{"constructor (provider: any, options: { schema: any })"}
	convertedMethods := make(map[string]struct{})
	for _, t := range apiTypes {
		for i := 0; i < t.NumMethod(); i++ {
			m := t.Method(i)
			_, converted := convertedMethods[m.Name]
			if converted {
				continue
			}
			convertedMethods[m.Name] = struct{}{}
			c.ConfigureFunc = func(t reflect.Type) go2ts.FuncConf {
				fconf := go2ts.FuncConf{IsMethod: true, MethodName: m.Name}
				if t.NumOut() > 0 && t.Out(0).Kind() == reflect.Chan {
					fconf.IsSync = true
				}
				return fconf
			}
			ts := c.Convert(m.Type)

			// deal with the API for subscriptions.
			//
			// go2ts generates a method that returns an AsyncIterable, we need to
			// convert into a method that takes a handler function as the first param
			// and returns a tuple with a cancel function and a ready promise. e.g.
			//
			// clientRetrieveWithEvents (retrievalOrder: RetrievalOrder, fileRef: FileRef): AsyncIterable<RetrievalEvent>
			// is converted to:
			// clientRetrieveWithEvents (handler: (data: RetrievalEvent) => void, retrievalOrder: RetrievalOrder, fileRef: FileRef): [() => void, Promise<void>]
			if isSub(m) {
				parts := strings.Split(ts, "): ")
				dataType := strings.Replace(parts[1][:len(parts[1])-1], "AsyncIterable<", "", 1)
				ts = parts[0] + "): [() => void, Promise<void>]"
				parts = strings.Split(ts, " (")
				if string(parts[1][0]) != ")" {
					ts = fmt.Sprintf("%s (handler: (data: %s) => void, %s", parts[0], dataType, parts[1])
				} else {
					ts = fmt.Sprintf("%s (handler: (data: %s) => void%s", parts[0], dataType, parts[1])
				}
			}

			if strings.HasPrefix(ts, "ID ") {
				ts = strings.Replace(ts, "ID ", "id ", 1)
			} else {
				ts = strings.ToLower(ts[0:1]) + ts[1:]
			}
			if doc, ok := mdocs[m.Name]; ok {
				methods = append(methods, "/**")
				lines := strings.Split(strings.TrimSpace(doc), "\n")
				for i, line := range lines {
					if i == 0 {
						line = strings.ToLower(line[0:1]) + line[1:]
					}
					methods = append(methods, " * "+line)
				}
				methods = append(methods, " */")
			}
			methods = append(methods, ts)
		}
	}

	// custom client methods
	methods = append(methods, "importFile (body: Blob | BufferSource | FormData | URLSearchParams | string | ReadableStream): string")
	methods = append(methods, "destroy (code?: number): void")

	decls = append(decls, fmt.Sprintf("declare class LotusRPC {\n  %s\n}", strings.Join(methods, "\n  ")))
	decls = append(decls, fmt.Sprintf("export { %s }", strings.Join(exports, ", ")))

	fmt.Println(strings.Join(decls, "\n"))
}

func isSub(m reflect.Method) bool {
	return m.Type.NumOut() >= 2 && m.Type.Out(0).Kind() == reflect.Chan
}
